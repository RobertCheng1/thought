## 单位换算


1 bit = 0/1 二进制数据
1 byte = 8 bit
1 字母 = 1 byte = 8 bit
1 汉字 = 2 byte = 16 bit

1G = 1024M(兆字节) = 1024*1024KB(千字节) = 1024\*1024\*1024B(字节) = 1024\*1024\*8bit（比特）



## 基本概念和术语

***数据***

反映客观事物的信息的集合，是信息的载体，能够被计算机识别、存储和加工处理

***数据元素***

集合中的个体，数据的基本单位，一个数据元素可以有多个数据项组成（字段、域、属性）

***数据项***

是具有独立含义的最小数据单位

***数据结构***

数据元素之间的逻辑关系

***存储结构***

数据元素及其关系在计算机存储器内的表示（大多数情况下都指内存）

***算法***

数据的运算，即对数据施加的操作

> ***身份证数据管理***   
> -      
> 数据元素：每一个身份证信息是一个数据元素     
> 数据项：姓名、性别、身份证号和相片     
> 数据结构：    
>
* 逻辑结构：线性表
* 物理结构：数组（顺序存储）
* 算法：增加、删除、查找


## 数据的逻辑结构

#### 特征

* 从逻辑关系上描述数据，与数据的存储无关
* 从具体问题抽象出来的数据模型
* 与数据元素本身的形式、内容无关

#### 逻辑结构分类

***集合结构*** 

数据元素间无任何关系

![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/1.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/1.png)

***

***线性结构*** 

元素之间的关系是1:1的

 ![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/2.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/2.png)
 
* 有且只有一个初始节点
* 最多有一个前驱，最多有一个后继（也可以没有）
* 插入或删除一个节点后仍满足前两条

例如：*线性表*

***

***非线性结构***

元素之间的关系是1:n的

![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/3.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/3.png)

* 一个节点可以多个直接后继（除叶子节点外），但只有一个直接前驱（除根节点外）

例如：*一般树、二叉树、森林*

***

***图状结构***

元素之间的关系是n:n的

![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/4.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/4.png)

* 一个节点可以有多个直接后继，也可以有多个直接前驱

***

## 数据结构的研究对象

* 非数值数据之间的结构关系
* 运算操作以插入、删除、查找、更改、排序为主

***


## 存储结构

***顺序存储***

* 位置即关系，节省空间
* 查询快，插入删除慢
* 内存碎片（内部碎片）




***链式存储***

* 数据元素要包含关系，空间开销大
* 插入删除快，查询则需遍历链表
* 没有碎片

`注：头节点可以不包含数据，也可以包含链表的长度。其有助于删除第一个元素，或者在第一个元素前插入数据`

`注：头指针是指向头节点的指针，无论链表是否为空，都存在头指针`

> 循环链表就是尾节点的next指向头节点，这样可以循环遍历

***

## 线性表

***规则***

* 只有一个前驱和一个后继
* 复杂线性表中，一个数据元素可以由若干个数据项组成

***

## 栈(LIFO)

![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/stack.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/stack.png)

***定义***

限定仅在表尾进行插入和删除操作的线性表

`也是线性表，一种特殊的线性表`

> 凡是那些需要临时保存前面数据元素的场景！访问轨迹、撤销命令、递归函数等等

***规则***

* 栈底的位置是永远不变的，栈顶执行一切操作
* 顺序存储时，指针指向栈顶
* 顺序存储时，栈的删除和添加都是在栈顶的，因此效率比普通的线性表高
* 顺序存储时，两栈可以共享空间。就是一个大数组里面包含两个栈，栈顶相对
* 链式存储时，第一个节点（不是头节点）就是栈顶，最后一个节点就是栈底

***应用***

*斐波那契数列* ----------------------------------

公式：F(n) = F(n-1)+F(n-2)

*四则运算表达式（后缀表达式／逆波兰表达式）*  ---------------------------------------

表达式：9+(3-1)*3+10/2 （这就是中缀表达式）`第一个＋记作+[1],第二个+记作+[2]`

后缀表达式：931-3*+[1]102/2+[2]

编号|后缀表达式|运算符|说明
:----|:-----|:----|:----
1|9|+[1]
2|93|+[1](
3|931|+[1](-
4|931-|+[1]|反括号优先级
5|931-|+[1]\*|\*号优先级高于+
6|931-3|+[1]\*
7|931-3\*+[1]|+[2]|+[2]的优先级小于等于原先的运算符
8|931-3\*+[1]10|+[2]
9|931-3\*+[1]10|+[2]/
10|931-3\*+[1]102|+[2]/
11|931-3\*+[1]102/+[2]

最后得到逆波兰式：931-3*+102/+

***

## 队列

![https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/queue.png](https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/queue.png)

***定义***

先进先出，特殊的线性表，队头出队尾进

> 一个个执行的地方都需要用,鼠标点击、cpu处理进程、秒杀活动、键盘打字等等

***顺序实现***

用数组申明一个空间，然后一个个的存入数据元素

* **问题1：** 0下标的位置是队头，如果出对，后面的元素都要向前挪一位，保持数组中的元素都是从0开始的
* **问题2：** 也可以不向前挪，直接出队，队头的位置下标变为1，这样可能会造成“假溢出”
* **最好的解决办法：** 头指针front,尾指针(rear)，加上循环队列（还是那个数组，rear指到最后的时候，可以跳转至0位置）,如果是固定长度适合。

> 队列满的条件：(rear+1) % QueueSize == front   
> 队列长度：(rear-front+QueueSize) % QueueSize




