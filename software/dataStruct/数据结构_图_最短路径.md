## 图_最短路径

### (两个顶点之间最小权重之和的路径)

### 迪杰斯特拉(Dijkstra)算法

<img src="https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/tu_minpath3.png" width="600" />

按照路径长度递增的产生最短路径的算法，也就是说不是一次性算出两个定点之间的最短距离，而是通过计算每个中间顶点的最短距离，最后推导出要求的顶点最短距离

<img src="https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/tu_minpath1.png" width="600" />

<img src="https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/tu_minpath2.png" width="600" />

1. 5~12行是初始化阶段，final一维数组值均为0，D数组记录所有顶点到v0的最短路径值，当前是{65535,1,5,65535,65535,65535,65535,65535,65535}，p数组全为0，表示目前还没有找到任意一个顶点的最短路径
2. 13行是一个主循环，每循环一次求得v0与一个顶点的最短路径，也就是让一个顶点的final值为1
3. 16～24行的循环，先令min为65535，通过w循环，与D[w]比较，找到目前最小的min和k值。当前是：D[1]的值最小，因为在第一次初始化的时候，v0连接的就两条边，v1和v2，如果是第二次循环，那就是D[2]
4. 25～32行，是在修正之前已经判定的v0和某个点的最短距离，例如：在初始化的时候v0到v2的最短距离是5，但是第一次循环完成之后，发现v0->v1＝min=1,v1->v2=3，因此v0->v1->v2=min+G.matirx[v1][v2]=4，这个值是小于D[2]=5的


### 佛洛伊德（floyd）算法

#### 原理

<img src="https://raw.githubusercontent.com/arkulo56/thought/master/images/datastruct/tu_minpath4.png" width="600" />


![](http://latex.codecogs.com/svg.latex?D^0)[v][w]=min{![](http://latex.codecogs.com/svg.latex?D^{-1})[v][w],![](http://latex.codecogs.com/svg.latex?D^{-1})[v][k]+![](http://latex.codecogs.com/svg.latex?D^{-1})[k][w]}


上面这个共识的含义就是：我们要判断所有顶点经过k顶点到达另一个顶点的最短路径。例如：v->w > v->k->w

